# -*- coding: utf-8 -*-

from __future__ import division


__author__ = """John Kirkham"""
__email__ = "kirkhamj@janelia.hhmi.org"


from ._version import get_versions
__version__ = get_versions()['version']
del get_versions


import numpy

import dask.array

from . import _compat
from . import _pycompat
from . import _utils


def center_of_mass(input, labels=None, index=None):
    """
    Calculate the center of mass of the values of an array at labels.

    Parameters
    ----------
    input : ndarray
        Data from which to calculate center-of-mass. The masses can either
        be positive or negative.
    labels : ndarray, optional
        Labels for objects in `input`, as generated by `ndimage.label`.
        Only used with `index`.  Dimensions must be the same as `input`.
    index : int or sequence of ints, optional
        Labels for which to calculate centers-of-mass. If not specified,
        all labels greater than zero are used.  Only used with `labels`.

    Returns
    -------
    center_of_mass : tuple, or list of tuples
        Coordinates of centers-of-mass.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    # SciPy transposes these for some reason.
    # So we do the same thing here.
    # This only matters if index is some array.
    index = index.T

    input_mtch_sum = sum(input, labels, index)

    input_i = _compat._indices(
        input.shape, dtype=numpy.int64, chunks=input.chunks
    )

    input_i_wt = input[None] * input_i

    input_i_wt_mtch_sum = []
    for i in _pycompat.irange(len(input_i_wt)):
        input_i_wt_mtch_sum.append(sum(input_i_wt[i], labels, index))
    input_i_wt_mtch_sum = dask.array.stack(input_i_wt_mtch_sum, axis=-1)

    com_lbl = input_i_wt_mtch_sum / input_mtch_sum[..., None]

    return com_lbl


def mean(input, labels=None, index=None):
    """
    Calculate the mean of the values of an array at labels.

    Parameters
    ----------
    input : array_like
        Array on which to compute the mean of elements over distinct
        regions.
    labels : array_like, optional
        Array of labels of same shape, or broadcastable to the same shape as
        `input`. All elements sharing the same label form one region over
        which the mean of the elements is computed.
    index : int or sequence of ints, optional
        Labels of the objects over which the mean is to be computed.
        Default is None, in which case the mean for all values where label is
        greater than 0 is calculated.

    Returns
    -------
    out : array_like
        Sequence of same length as `index`, with the mean of the different
        regions labeled by the labels in `index`.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    input_sum = sum(input, labels, index)
    input_norm = sum(
        dask.array.ones(input.shape, dtype=input.dtype, chunks=input.chunks),
        labels,
        index
    )

    com_lbl = input_sum / input_norm

    return com_lbl


def sum(input, labels=None, index=None):
    """
    Calculate the sum of the values of the array.

    Parameters
    ----------
    input : array_like
        Values of `input` inside the regions defined by `labels`
        are summed together.
    labels : array_like of ints, optional
        Assign labels to the values of the array. Has to have the same shape as
        `input`.
    index : array_like, optional
        A single label number or a sequence of label numbers of
        the objects to be measured.

    Returns
    -------
    sum : ndarray or scalar
        An array of the sums of values of `input` inside the regions defined
        by `labels` with the same shape as `index`. If 'index' is None or scalar,
        a scalar is returned.
    """

    input, labels, index = _utils._norm_input_labels_index(
        input, labels, index
    )

    lbl_mtch = _utils._get_label_matches(labels, index)

    input_mtch = dask.array.where(
        lbl_mtch, input[index.ndim * (None,)], input.dtype.type(0)
    )

    input_mtch = input_mtch.astype(numpy.float64)

    sum_lbl = input_mtch.sum(
        axis=tuple(_pycompat.irange(index.ndim, input_mtch.ndim))
    )

    return sum_lbl
